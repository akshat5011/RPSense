<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RPSense Backend Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #1a1a1a;
            color: white;
        }
        
        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .section {
            background: #2a2a2a;
            border-radius: 10px;
            padding: 20px;
            border: 1px solid #444;
        }
        
        .section h2 {
            color: #00bcd4;
            margin-top: 0;
        }
        
        video, canvas {
            width: 100%;
            max-width: 400px;
            height: 300px;
            border-radius: 8px;
            border: 2px solid #00bcd4;
        }
        
        .controls {
            margin: 15px 0;
        }
        
        button {
            background: #00bcd4;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            font-size: 14px;
        }
        
        button:hover {
            background: #0097a7;
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        .status {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-weight: bold;
        }
        
        .status.success { background: #4caf50; }
        .status.error { background: #f44336; }
        .status.warning { background: #ff9800; }
        .status.info { background: #2196f3; }
        
        .result-section {
            grid-column: 1 / -1;
            background: #2a2a2a;
            border-radius: 10px;
            padding: 20px;
            border: 1px solid #444;
        }
        
        .result-images {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        
        .result-image {
            text-align: center;
        }
        
        .result-image img {
            max-width: 100%;
            border-radius: 8px;
            border: 2px solid #00bcd4;
        }
        
        .prediction-info {
            background: #333;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
        }
        
        .config {
            background: #333;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
        }
        
        .logs {
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 8px;
            padding: 15px;
            max-height: 300px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
        }
        
        input[type="text"], input[type="number"] {
            background: #444;
            color: white;
            border: 1px solid #666;
            padding: 8px;
            border-radius: 4px;
            margin: 5px;
        }
        
        .frame-counter {
            color: #00bcd4;
            font-weight: bold;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <h1>üéÆ RPSense Backend Test Interface</h1>
    
    <!-- Configuration Section -->
    <div class="section">
        <h2>‚öôÔ∏è Configuration</h2>
        <div class="config">
            <label>Backend URL: 
                <input type="text" id="backendUrl" value="{{request.url_root}}" style="width: 300px;">
            </label><br>
            <label>Frame Interval (ms): 
                <input type="number" id="frameInterval" value="1000" min="100" max="5000">
            </label><br>
            <label>Auto Stop After (frames): 
                <input type="number" id="autoStopFrames" value="25" min="5" max="100">
            </label>
        </div>
    </div>
    
    <div class="container">
        <!-- Camera Section -->
        <div class="section">
            <h2>üìπ Camera Feed</h2>
            <video id="video" autoplay muted></video>
            <div class="controls">
                <button id="startCamera">Start Camera</button>
                <button id="stopCamera" disabled>Stop Camera</button>
            </div>
            <div id="cameraStatus" class="status info">Camera not started</div>
        </div>
        
        <!-- Processing Section -->
        <div class="section">
            <h2>üîÑ Frame Processing</h2>
            <canvas id="canvas" style="display: none;"></canvas>
            <div class="controls">
                <button id="startProcessing" disabled>Start Processing</button>
                <button id="stopProcessing" disabled>Stop Processing</button>
                <button id="sendSingleFrame" disabled>Send Single Frame</button>
            </div>
            <div class="frame-counter">
                Frames Sent: <span id="frameCount">0</span>
            </div>
            <div id="processingStatus" class="status info">Processing not started</div>
        </div>
    </div>
    
    <!-- Results Section -->
    <div class="result-section">
        <h2>üìä Results</h2>
        
        <!-- Real-time Results -->
        <div id="realtimeResults">
            <h3>‚ö° Real-time Predictions</h3>
            <div id="realtimePrediction" class="prediction-info">
                No predictions yet...
            </div>
        </div>
        
        <!-- Final Results -->
        <div id="finalResults" style="margin-top: 20px;">
            <h3>üéØ Final Aggregated Result</h3>
            <div id="finalPrediction" class="prediction-info">
                No final result yet...
            </div>
        </div>
        
        <!-- Result Images -->
        <div class="result-images">
            <div class="result-image">
                <h4>Real-time Overlay</h4>
                <img id="realtimeImage" src="" alt="Real-time result" style="display: none;">
                <div id="noRealtimeImage" style="color: #666;">No real-time image</div>
            </div>
            <div class="result-image">
                <h4>Final Result Overlay</h4>
                <img id="finalImage" src="" alt="Final result" style="display: none;">
                <div id="noFinalImage" style="color: #666;">No final image</div>
            </div>
        </div>
    </div>
    
    <!-- Logs Section -->
    <div class="result-section">
        <h2>üìã Logs</h2>
        <div id="logs" class="logs"></div>
        <button onclick="clearLogs()">Clear Logs</button>
    </div>

    <script>
        // Global variables
        let video = document.getElementById('video');
        let canvas = document.getElementById('canvas');
        let ctx = canvas.getContext('2d');
        let stream = null;
        let processingInterval = null;
        let frameCount = 0;
        let backendUrl = document.getElementById('backendUrl').value;
        
        // Utility functions
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logElement = document.getElementById('logs');
            const logEntry = document.createElement('div');
            logEntry.style.color = type === 'error' ? '#f44336' : 
                                 type === 'success' ? '#4caf50' : 
                                 type === 'warning' ? '#ff9800' : '#ffffff';
            logEntry.textContent = `[${timestamp}] ${message}`;
            logElement.appendChild(logEntry);
            logElement.scrollTop = logElement.scrollHeight;
        }
        
        function clearLogs() {
            document.getElementById('logs').innerHTML = '';
        }
        
        function updateStatus(elementId, message, type) {
            const element = document.getElementById(elementId);
            element.textContent = message;
            element.className = `status ${type}`;
        }
        
        // Camera functions
        async function startCamera() {
            try {
                stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { width: 640, height: 480 } 
                });
                video.srcObject = stream;
                
                video.onloadedmetadata = () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                };
                
                document.getElementById('startCamera').disabled = true;
                document.getElementById('stopCamera').disabled = false;
                document.getElementById('startProcessing').disabled = false;
                document.getElementById('sendSingleFrame').disabled = false;
                
                updateStatus('cameraStatus', 'Camera started successfully', 'success');
                log('Camera started successfully', 'success');
            } catch (error) {
                updateStatus('cameraStatus', `Camera error: ${error.message}`, 'error');
                log(`Camera error: ${error.message}`, 'error');
            }
        }
        
        function stopCamera() {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                video.srcObject = null;
                stream = null;
            }
            
            stopProcessing();
            
            document.getElementById('startCamera').disabled = false;
            document.getElementById('stopCamera').disabled = true;
            document.getElementById('startProcessing').disabled = true;
            document.getElementById('sendSingleFrame').disabled = true;
            
            updateStatus('cameraStatus', 'Camera stopped', 'info');
            log('Camera stopped', 'info');
        }
        
        // Frame processing functions
        function captureFrame() {
            if (!video.videoWidth || !video.videoHeight) {
                return null;
            }
            
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            return canvas.toDataURL('image/jpeg', 0.8);
        }
        
        async function sendFrame() {
            try {
                const frameDataUrl = captureFrame();
                if (!frameDataUrl) {
                    log('Failed to capture frame', 'error');
                    return;
                }
                
                // Convert data URL to blob
                const response = await fetch(frameDataUrl);
                const blob = await response.blob();
                
                // Prepare form data
                const formData = new FormData();
                formData.append('frame', blob, 'frame.jpg');
                formData.append('gameData', JSON.stringify({
                    gameMode: 'test',
                    totalRounds: 5,
                    currentRound: 1,
                    playerScore: 0,
                    computerScore: 0,
                    timestamp: Date.now()
                }));
                
                // Update backend URL
                backendUrl = document.getElementById('backendUrl').value;
                
                // Send to backend
                const result = await fetch(`${backendUrl}/gameplay`, {
                    method: 'POST',
                    body: formData
                });
                
                if (!result.ok) {
                    throw new Error(`HTTP ${result.status}: ${result.statusText}`);
                }
                
                const data = await result.json();
                frameCount++;
                document.getElementById('frameCount').textContent = frameCount;
                
                // Handle real-time result
                if (data.real_time) {
                    handleRealtimeResult(data.real_time);
                }
                
                // Handle final result
                if (data.final_result) {
                    handleFinalResult(data.final_result);
                }
                
                // Auto-stop if reached limit
                const autoStopFrames = parseInt(document.getElementById('autoStopFrames').value);
                if (frameCount >= autoStopFrames) {
                    stopProcessing();
                    log(`Auto-stopped after ${autoStopFrames} frames`, 'warning');
                }
                
            } catch (error) {
                log(`Frame processing error: ${error.message}`, 'error');
                updateStatus('processingStatus', `Error: ${error.message}`, 'error');
            }
        }
        
        function handleRealtimeResult(result) {
            const realtimeDiv = document.getElementById('realtimePrediction');
            
            if (result.status === 'success') {
                realtimeDiv.innerHTML = `
                    <strong>Prediction:</strong> ${result.prediction.toUpperCase()}<br>
                    <strong>Confidence:</strong> ${(result.confidence * 100).toFixed(1)}%<br>
                    <strong>Buffer Size:</strong> ${result.buffer_size} frames<br>
                    <strong>Timestamp:</strong> ${new Date(result.timestamp * 1000).toLocaleTimeString()}
                `;
                
                // Show overlay image
                if (result.overlay_image) {
                    const img = document.getElementById('realtimeImage');
                    img.src = result.overlay_image;
                    img.style.display = 'block';
                    document.getElementById('noRealtimeImage').style.display = 'none';
                }
                
                log(`Real-time: ${result.prediction} (${(result.confidence * 100).toFixed(1)}%)`, 'success');
            } else {
                realtimeDiv.innerHTML = `
                    <strong>Status:</strong> ${result.status}<br>
                    <strong>Message:</strong> ${result.message}
                `;
                log(`Real-time: ${result.status} - ${result.message}`, 'warning');
            }
        }
        
        function handleFinalResult(result) {
            const finalDiv = document.getElementById('finalPrediction');
            
            finalDiv.innerHTML = `
                <strong>üéØ Final Prediction:</strong> ${result.final_prediction.toUpperCase()}<br>
                <strong>Confidence:</strong> ${(result.confidence * 100).toFixed(1)}%<br>
                <strong>Frame Count:</strong> ${result.frame_count}<br>
                <strong>Prediction %:</strong> ${result.prediction_percentage.toFixed(1)}%<br>
                <strong>All Predictions:</strong> ${JSON.stringify(result.all_predictions)}<br>
                <strong>Timestamp:</strong> ${new Date(result.timestamp * 1000).toLocaleTimeString()}
            `;
            
            // Show final overlay image
            if (result.final_overlay_image) {
                const img = document.getElementById('finalImage');
                img.src = result.final_overlay_image;
                img.style.display = 'block';
                document.getElementById('noFinalImage').style.display = 'none';
            }
            
            log(`üéØ FINAL RESULT: ${result.final_prediction} (${(result.confidence * 100).toFixed(1)}%)`, 'success');
        }
        
        function startProcessing() {
            const interval = parseInt(document.getElementById('frameInterval').value);
            
            processingInterval = setInterval(sendFrame, interval);
            
            document.getElementById('startProcessing').disabled = true;
            document.getElementById('stopProcessing').disabled = false;
            
            updateStatus('processingStatus', `Processing started (${interval}ms interval)`, 'success');
            log(`Frame processing started with ${interval}ms interval`, 'success');
        }
        
        function stopProcessing() {
            if (processingInterval) {
                clearInterval(processingInterval);
                processingInterval = null;
            }
            
            document.getElementById('startProcessing').disabled = false;
            document.getElementById('stopProcessing').disabled = true;
            
            updateStatus('processingStatus', 'Processing stopped', 'info');
            log('Frame processing stopped', 'info');
        }
        
        // Event listeners
        document.getElementById('startCamera').addEventListener('click', startCamera);
        document.getElementById('stopCamera').addEventListener('click', stopCamera);
        document.getElementById('startProcessing').addEventListener('click', startProcessing);
        document.getElementById('stopProcessing').addEventListener('click', stopProcessing);
        document.getElementById('sendSingleFrame').addEventListener('click', sendFrame);
        
        // Initialize
        log('RPSense Backend Test Interface loaded', 'info');
        log('1. Configure backend URL if needed', 'info');
        log('2. Start camera', 'info');
        log('3. Start processing or send single frame', 'info');
    </script>
</body>
</html>